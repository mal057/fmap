/**
 * Malware Scanning Service
 * Integrates with VirusTotal API and provides file hash checking
 */

/**
 * VirusTotal scan result
 */
export interface VirusTotalResult {
  scanned: boolean;
  malicious: boolean;
  suspicious: boolean;
  harmless: boolean;
  undetected: boolean;
  scanId?: string;
  positives?: number;
  total?: number;
  permalink?: string;
}

/**
 * Malware scan result
 */
export interface MalwareScanResult {
  safe: boolean;
  reason?: string;
  sha256?: string;
  virusTotal?: VirusTotalResult;
  quarantined?: boolean;
}

/**
 * Calculate SHA-256 hash of file
 */
async function calculateSha256(file: File): Promise<string> {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

/**
 * Known malware hashes (example - should be maintained in a database)
 */
const KNOWN_MALWARE_HASHES = new Set<string>([
  // Add known malware SHA-256 hashes here
  // This is just an example structure
]);

/**
 * Check if file hash is in known malware database
 */
function isKnownMalware(sha256: string): boolean {
  return KNOWN_MALWARE_HASHES.has(sha256.toLowerCase());
}

/**
 * Check file with VirusTotal API
 * @param apiKey VirusTotal API key
 * @param sha256 File SHA-256 hash
 */
async function checkVirusTotal(
  apiKey: string,
  sha256: string
): Promise<VirusTotalResult> {
  try {
    // First, check if the file is already known to VirusTotal
    const reportResponse = await fetch(
      `https://www.virustotal.com/api/v3/files/${sha256}`,
      {
        headers: {
          'x-apikey': apiKey,
        },
      }
    );

    if (reportResponse.ok) {
      const data = await reportResponse.json() as any;
      const stats = data.data?.attributes?.last_analysis_stats || {};

      return {
        scanned: true,
        malicious: stats.malicious > 0,
        suspicious: stats.suspicious > 0,
        harmless: stats.harmless > 0,
        undetected: stats.undetected > 0,
        positives: stats.malicious + stats.suspicious,
        total: Object.values(stats).reduce((a: number, b: any) => a + (b || 0), 0) as number,
        permalink: `https://www.virustotal.com/gui/file/${sha256}`,
      };
    }

    // If not found, we would upload it (requires paid API for programmatic upload)
    // For free tier, we just return that it hasn't been scanned
    return {
      scanned: false,
      malicious: false,
      suspicious: false,
      harmless: false,
      undetected: false,
    };
  } catch (error) {
    console.error('VirusTotal API error:', error);
    return {
      scanned: false,
      malicious: false,
      suspicious: false,
      harmless: false,
      undetected: false,
    };
  }
}

/**
 * Upload file to VirusTotal for scanning (requires API key with upload permission)
 * Note: Free tier has limits on uploads
 */
async function uploadToVirusTotal(
  apiKey: string,
  file: File
): Promise<{ scanId?: string; error?: string }> {
  try {
    // Get upload URL
    const urlResponse = await fetch('https://www.virustotal.com/api/v3/files/upload_url', {
      headers: {
        'x-apikey': apiKey,
      },
    });

    if (!urlResponse.ok) {
      return { error: 'Failed to get upload URL' };
    }

    const urlData = await urlResponse.json() as any;
    const uploadUrl = urlData.data;

    // Upload file
    const formData = new FormData();
    formData.append('file', file);

    const uploadResponse = await fetch(uploadUrl, {
      method: 'POST',
      headers: {
        'x-apikey': apiKey,
      },
      body: formData,
    });

    if (!uploadResponse.ok) {
      return { error: 'Failed to upload file' };
    }

    const uploadData = await uploadResponse.json() as any;
    return { scanId: uploadData.data?.id };
  } catch (error) {
    console.error('VirusTotal upload error:', error);
    return { error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

/**
 * Basic heuristic checks for suspicious file patterns
 */
function performHeuristicCheck(file: File): { suspicious: boolean; reason?: string } {
  // Check for suspicious file names
  const suspiciousNames = [
    /\.exe$/i,
    /\.dll$/i,
    /\.bat$/i,
    /\.cmd$/i,
    /\.com$/i,
    /\.scr$/i,
    /\.vbs$/i,
    /\.js$/i,
    /\.jar$/i,
  ];

  for (const pattern of suspiciousNames) {
    if (pattern.test(file.name)) {
      return {
        suspicious: true,
        reason: `Potentially dangerous file extension: ${file.name}`,
      };
    }
  }

  // Check for double extensions
  const parts = file.name.split('.');
  if (parts.length > 2) {
    const secondExt = parts[parts.length - 2].toLowerCase();
    const suspiciousSecondExts = ['exe', 'bat', 'cmd', 'com', 'scr', 'vbs'];

    if (suspiciousSecondExts.includes(secondExt)) {
      return {
        suspicious: true,
        reason: `Suspicious double extension: ${file.name}`,
      };
    }
  }

  return { suspicious: false };
}

/**
 * Scan file for malware
 */
export async function scanFile(
  file: File,
  options: {
    virusTotalApiKey?: string;
    checkKnownHashes?: boolean;
    performHeuristics?: boolean;
    uploadToVirusTotal?: boolean;
  } = {}
): Promise<MalwareScanResult> {
  // Calculate file hash
  const sha256 = await calculateSha256(file);

  // Check known malware hashes
  if (options.checkKnownHashes !== false) {
    if (isKnownMalware(sha256)) {
      return {
        safe: false,
        reason: 'File hash matches known malware',
        sha256,
        quarantined: true,
      };
    }
  }

  // Perform heuristic checks
  if (options.performHeuristics !== false) {
    const heuristicResult = performHeuristicCheck(file);
    if (heuristicResult.suspicious) {
      return {
        safe: false,
        reason: heuristicResult.reason,
        sha256,
        quarantined: true,
      };
    }
  }

  // Check with VirusTotal if API key provided
  let virusTotalResult: VirusTotalResult | undefined;

  if (options.virusTotalApiKey) {
    virusTotalResult = await checkVirusTotal(options.virusTotalApiKey, sha256);

    // If file is malicious or suspicious
    if (virusTotalResult.malicious || virusTotalResult.suspicious) {
      return {
        safe: false,
        reason: `VirusTotal detected threats: ${virusTotalResult.positives}/${virusTotalResult.total} scanners flagged this file`,
        sha256,
        virusTotal: virusTotalResult,
        quarantined: true,
      };
    }

    // If file hasn't been scanned and upload is enabled
    if (!virusTotalResult.scanned && options.uploadToVirusTotal) {
      const uploadResult = await uploadToVirusTotal(options.virusTotalApiKey, file);

      if (uploadResult.scanId) {
        console.log(`File uploaded to VirusTotal for scanning: ${uploadResult.scanId}`);
        // In production, you might want to queue this file for re-checking later
      }
    }
  }

  // File appears safe
  return {
    safe: true,
    sha256,
    virusTotal: virusTotalResult,
    quarantined: false,
  };
}

/**
 * Quarantine a file (move to quarantine bucket/prefix)
 */
export async function quarantineFile(
  bucket: R2Bucket,
  fileKey: string,
  scanResult: MalwareScanResult
): Promise<boolean> {
  try {
    // Get the file
    const file = await bucket.get(fileKey);
    if (!file) return false;

    // Move to quarantine
    const quarantineKey = `quarantine/${Date.now()}-${fileKey}`;
    await bucket.put(quarantineKey, file.body, {
      customMetadata: {
        originalKey: fileKey,
        quarantineReason: scanResult.reason || 'Malware detected',
        sha256: scanResult.sha256 || '',
        quarantineTime: new Date().toISOString(),
      },
    });

    // Delete original
    await bucket.delete(fileKey);

    console.log(`File quarantined: ${fileKey} -> ${quarantineKey}`);
    return true;
  } catch (error) {
    console.error('Error quarantining file:', error);
    return false;
  }
}

/**
 * Malware scan middleware
 */
export async function malwareScanMiddleware(
  request: Request,
  options: {
    virusTotalApiKey?: string;
    enabled?: boolean;
  } = {}
): Promise<Response | null> {
  // Skip if scanning is disabled
  if (options.enabled === false) {
    return null;
  }

  // Only scan file uploads
  if (request.method !== 'POST') {
    return null;
  }

  const contentType = request.headers.get('content-type') || '';
  if (!contentType.includes('multipart/form-data')) {
    return null;
  }

  try {
    const formData = await request.clone().formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return null;
    }

    // Scan the file
    const scanResult = await scanFile(file, {
      virusTotalApiKey: options.virusTotalApiKey,
      checkKnownHashes: true,
      performHeuristics: true,
      uploadToVirusTotal: false, // Don't auto-upload to avoid rate limits
    });

    if (!scanResult.safe) {
      return new Response(
        JSON.stringify({
          error: 'File rejected by security scan',
          reason: scanResult.reason,
          code: 'MALWARE_DETECTED',
        }),
        {
          status: 403,
          headers: { 'Content-Type': 'application/json' },
        }
      );
    }

    return null; // File is safe, pass through
  } catch (error) {
    console.error('Malware scan error:', error);
    // Fail open - allow the request but log the error
    return null;
  }
}

/**
 * ClamAV integration (for self-hosted deployments)
 * This would require a ClamAV service running somewhere accessible
 */
export async function scanWithClamAV(
  file: File,
  clamavUrl: string
): Promise<MalwareScanResult> {
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch(`${clamavUrl}/scan`, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      return {
        safe: true, // Fail open
        reason: 'ClamAV service unavailable',
      };
    }

    const result = await response.json() as any;

    return {
      safe: result.is_infected === false,
      reason: result.viruses?.join(', ') || undefined,
      quarantined: result.is_infected === true,
    };
  } catch (error) {
    console.error('ClamAV scan error:', error);
    return {
      safe: true, // Fail open
      reason: 'ClamAV scan failed',
    };
  }
}
